package pry1_ci;

import java_cup.runtime.*;

import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import VerificadorTipos;
/* Errores
    creacion y asignacion variables de tipo flotante revisar bien
    problemas en la declaracion de operaciones
    retornar identificador
*/

action code {:
    HashMap<String, HashMap<String, String>> listaTablasSimbolos = new HashMap<String, HashMap<String, String>>();
    String tablaActual;
    VerificadorTipos verificador = new VerificadorTipos();
    
    public void imprimirTabla() {
        /*System.out.println("[IMPRIMIENDO TABLA DE SIMBOLOS]\n");
        for (String key: listaTablasSimbolos.keySet()) {
            System.out.println("Tabla de simbolos Funcion:"+ key);
            System.out.println("Valores del bloque de funcion ");
            for (String item : listaTablasSimbolos.get(key)) {
                System.out.println(item);
            }
            System.out.println("");
        }*/
        System.out.println("[#----------------------Impresion de Tabla de Simbolos----------------------#]\n");
        
        for (String i : listaTablasSimbolos.keySet()) {
            System.out.println("Nombre de funcion = "+ i);
            HashMap<String, String> temp = listaTablasSimbolos.get(i);
            for (String j:temp.keySet()) {
                System.out.println("\t\t| Nombre simbolo:"+j+" Tipo simbolo:"+temp.get(j));
            }
        }
        System.out.println("\n[#----------------------Fin Tabla de Simbolos----------------------#]");
    }
    
    
        
    




:}



parser code  {: 
    public void report_error(String message, Object info) {
        String m = "Error sintactico ";
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m+="en la linea "+(s.left+1)+" -> ";
            }
        }
        m+="["+message+"]";
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        
    }
  
public void semantic_error(String tipo, String valor) {
    
    System.err.println("Error semantico "+tipo+" -> "+valor);

  }  
:};





//init with {: :};
//scan with {: return lexer.next_token(); :};



// Terminales
terminal FIN_EXPRESION;
terminal IF, ELSE, ELIF, WHILE, DO, FOR, BREAK, RETURN;
terminal BOOL, CHAR, FLOAT, INT, STRING;

// Comentarios
terminal COMENTARIO;

// Entrada y salida estandar
terminal SYS_PRINT, SYS_READ;

// Operadores
terminal EQEQ, PLUS, EQ, TIMES, MINUS, DIVI, NOT_EQ, POWER, MODULO;
terminal NEGACION, CONJUNCION, DISYUNCION, MINUSMINUS, PLUSPLUS, GREATER_THAN, LESS_THAN;
terminal GREATER_THAN_OR_EQ, LESS_THAN_OR_EQ;

// Parentesis
terminal PARENTESISABRE, PARENTESISCIERRA, LLAVESCORCHETEABRE, LLAVESCORCHETECIERRA, COMA;
terminal LLAVESCUADABRE, LLAVESCUADCIERRA, SEMI;

// Literales
terminal java.lang.Number L_ENTERO;
terminal java.lang.Number L_FLOTANTE;
terminal java.lang.Boolean L_BOOLEANO;
terminal java.lang.Character L_CHAR;
terminal java.lang.String STRING_LITERAL;

// Identificador
terminal java.lang.String Identificador;

// No terminales

// Estructura del programa
non terminal inicio, main, programa, bloqueCod, return, bloqueControl;

// Funciones
non terminal crearFuncion, funcion, funciones, parametro, crearParametro, tipoIDFun;

// Sentencias
non terminal sentencia, crearVariable, crearAsignarVariable, asignarVariable;
//, obtenerDatoString, asignarElementoString;
non terminal entradaEst, salidaEst;

// Estructuras de control
non terminal estructControl, if, elif, else, while, do, for, condicion, break;

// Expresiones
non terminal expresion, operando;
non terminal expresionBinaria, expresionUnaria, expresionRelacion, expresionNegacion, expresionConjuntiva;
non terminal operadorNegacion, operadorBinario, operadorRelacional, operadorUnario, operadorComparacion, operadorConjuntiva;

// Tipos
non terminal literal;
non terminal arreglo, elementoArreglo, crearArreglo, asignarElementoArreglo, obtenerDatoArreglo;
non terminal tipoVariable, tipoFuncion;



/* Precedencia */
precedence left PLUS, MINUS;
precedence left EQEQ, NOT_EQ;
precedence left GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQ, LESS_THAN_OR_EQ;
precedence left TIMES, DIVI, MODULO;
precedence left POWER;
precedence left CONJUNCION;
precedence left DISYUNCION;
precedence left IF, ELIF, ELSE;
precedence left LLAVESCORCHETEABRE, LLAVESCORCHETECIERRA, PARENTESISABRE, PARENTESISCIERRA;


start with inicio;

//Programa Principal-----------------------------------------------------------------------------------------------------|
inicio ::= programa {:imprimirTabla();:};
programa ::= main funciones
           
;
//Funcion o funciones----------------------------------------------------------------------------------------------------|
funciones ::= funciones crearFuncion
            | crearFuncion 
;

main ::= tipoIDFun PARENTESISABRE PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA
{: System.out.println("Cierra tabla de simbolos\n"); :}
;

// Produccion de bloque de codigo
bloqueCod ::= sentencia 
            | estructControl 
            | return 
            | sentencia bloqueCod
            | estructControl bloqueCod
            | COMENTARIO
;

// Produccion de sentencias
sentencia ::= crearVariable FIN_EXPRESION 
            | crearAsignarVariable FIN_EXPRESION
            | asignarVariable FIN_EXPRESION
           // | crearArreglo FIN_EXPRESION //resolver a nivel semantico
            | asignarElementoArreglo FIN_EXPRESION
            | obtenerDatoArreglo FIN_EXPRESION
            | expresion FIN_EXPRESION
            | funcion FIN_EXPRESION
            | entradaEst:vET FIN_EXPRESION
            | salidaEst FIN_EXPRESION
            | error {:System.err.println("Error Sintactico recuperado");:}sentencia

;



// Produccion de creacion y asignacion de variables---------------------------------------------------------------------------|
crearVariable ::= tipoVariable:vTV Identificador:vID 
                   {:
                        //System.out.println("[PARSER] Funcion TIPO: "+vTV+" ID: "+vID);
                        listaTablasSimbolos.get(tablaActual).put(vID.toString(), vTV.toString());
                        RESULT = vID;
                    :}
;

crearAsignarVariable ::= crearVariable:vID EQ literal:vL 
{:
    String tipo = listaTablasSimbolos.get(tablaActual).get(vID).toString();
    String valor = vL.toString();
    
    if (!verificador.opciones(tipo, valor, vL)) {semantic_error(tipo, valor);}
    
 :}
                       | crearVariable EQ expresion 
                       | crearVariable EQ Identificador 
                       | crearVariable EQ funcion
                       | crearVariable FIN_EXPRESION
;
asignarVariable	::= Identificador EQ literal 
                  | Identificador EQ expresion 
                  | Identificador EQ Identificador 
                  | Identificador EQ funcion 
;

// Produccion de arreglos
arreglo ::= LLAVESCUADABRE LLAVESCUADCIERRA;


asignarElementoArreglo	::= elementoArreglo  EQ L_ENTERO 
                          | elementoArreglo  EQ  L_CHAR
;
// preguntar
elementoArreglo	::= Identificador LLAVESCUADABRE L_ENTERO LLAVESCUADCIERRA
                  | Identificador LLAVESCUADABRE Identificador LLAVESCUADCIERRA
;
obtenerDatoArreglo ::= Identificador LLAVESCUADABRE L_ENTERO LLAVESCUADCIERRA
                     | Identificador LLAVESCUADABRE Identificador LLAVESCUADCIERRA
;

// Produccion de expresiones
expresion ::= expresionBinaria 
            | expresionUnaria 
            | expresionRelacion 
            | expresionNegacion 
            | expresionConjuntiva
;

// Produccion de creacion de funciones
funcion	::= Identificador:vID PARENTESISABRE PARENTESISCIERRA //{: System.out.println("[PARSER] Funcion ID:"+vID); :}
          | Identificador PARENTESISABRE parametro PARENTESISCIERRA 
;

crearFuncion ::= tipoIDFun PARENTESISABRE PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA 
{: System.out.println("Cierra tabla de simbolos\n"); :}
               | tipoIDFun PARENTESISABRE Identificador PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA 
{: System.out.println("Cierra tabla de simbolos\n"); :}
               | tipoIDFun PARENTESISABRE literal  PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA
{: System.out.println("Cierra tabla de simbolos\n"); :}
               | tipoIDFun PARENTESISABRE crearParametro  PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA
{: System.out.println("Cierra tabla de simbolos\n"); :}
;

tipoIDFun ::= tipoFuncion:vTF Identificador:vID 
{:
    System.out.println("Nueva tabla de simbolos Funcion:"+vID);
    //String tipoTabla = "";

   // if (vID.toString().equals("main")) tipoTabla = "Funcion [main], tipo:"+vTF.toString();
   // else {tipoTabla = "Funcion ["+vID+"], tipo :"+vTF.toString();}

    //ArrayList<String> funciones = new ArrayList<String>();
    tablaActual = vID.toString();
    //System.out.println(nombreFun);
    //funciones.add(tipoTabla);
    
    HashMap<String, String> datosFuncion = new HashMap<String, String>();
    datosFuncion.put(tablaActual, vTF.toString());



    //System.out.println(listaTablasSimbolos);
    listaTablasSimbolos.put(tablaActual, datosFuncion);
    
    
:}
;
 

// Produccion de creacion de parametros
parametro ::= Identificador
            | literal
            | funcion
            | Identificador COMA parametro
;

crearParametro ::= tipoVariable Identificador
                 | tipoVariable Identificador COMA crearParametro
;

// Produccion de funcion de entrada estandar
entradaEst ::= SYS_READ PARENTESISABRE L_ENTERO PARENTESISCIERRA
             | SYS_READ PARENTESISABRE L_FLOTANTE PARENTESISCIERRA
;

// Produccion de funcion de salida estandar
salidaEst ::= SYS_PRINT PARENTESISABRE Identificador:vID PARENTESISCIERRA //{: System.out.println("[PARSER] SysPrint Identificador: " +vID); :}
            | SYS_PRINT PARENTESISABRE literal:vL PARENTESISCIERRA //{: System.out.println("[PARSER] SysPrint: " +vL); :}
;

// Produccion de estructuras de control
estructControl ::= if 
                | elif 
                | else 
                | while
                | do
                | for
;

// Produccion de IF
if ::= IF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
      | IF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA elif
      | IF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA else
;

// Produccion de ELIF
elif ::= if ELIF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA;

// Produccion de ELSE
else ::= if ELSE LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA;

// Produccion de WHILE
while ::= WHILE PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA;

// Produccion de DO
do ::= DO LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA WHILE PARENTESISABRE condicion PARENTESISCIERRA;

// Produccion de bloque de control
bloqueControl ::= bloqueCod 
                | break
;

for ::= FOR PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
      | FOR PARENTESISABRE L_BOOLEANO PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
      | FOR PARENTESISABRE expresionConjuntiva PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
;

// Produccion de BREAK
break ::= BREAK FIN_EXPRESION;

// Produccion de RETURN
return ::= RETURN literal:iDL FIN_EXPRESION //{: System.out.println("[PASER] RETURN: "+iDL); :}
         | RETURN expresion FIN_EXPRESION
         | RETURN Identificador FIN_EXPRESION
         | RETURN funcion FIN_EXPRESION
;

// Produccion de condicion
condicion ::= L_BOOLEANO 
            | expresionRelacion 
            | expresionNegacion
;

// Produccion de expresiones relaciones
expresionRelacion ::= operando operadorRelacional operando
                    | operando operadorComparacion operando
;
operadorRelacional ::= GREATER_THAN
                     | LESS_THAN
                     | GREATER_THAN_OR_EQ
                     | LESS_THAN_OR_EQ
;
operadorComparacion	::= EQEQ
                      | NOT_EQ
;

// Produccion de expresiones de negacion
expresionNegacion ::= operadorNegacion operando;

operadorNegacion ::= NEGACION;

// Produccion de expresiones unarias
expresionUnaria	::= operando operadorUnario
                  | MINUS operando
;

operadorUnario	::= MINUSMINUS
                  | PLUSPLUS
;

// Produccion de expresiones Binarias
expresionBinaria ::= operando operadorBinario operando;
operadorBinario ::= PLUS
                  | MINUS
                  | DIVI
                  | TIMES
                  | POWER
                  | MODULO
;

// Produccion de expresiones Conjuntivas
expresionConjuntiva	::= operando operadorConjuntiva operando;
operadorConjuntiva	::= CONJUNCION
                      | DISYUNCION
;
operando ::= literal:vL {: RESULT = vL; :} 
           | Identificador:vI {: RESULT = vI; :} 
           | funcion:vRes {: RESULT = vRes; :}
;

// Produccion de los tipos de funcion
tipoFuncion ::=  INT {: RESULT = "int"; :}
               | BOOL {: RESULT = "bool"; :}
               | FLOAT {: RESULT = "float"; :}
;

// Produccion de los tipos de variables
tipoVariable ::= INT {: RESULT = "int"; :} 
               | BOOL {: RESULT = "bool"; :} 
               | FLOAT {: RESULT = "float"; :} 
               | CHAR {: RESULT = "char"; :} 
               | STRING:s {: RESULT = "string"; :} 
;

// Produccion de los literales
literal ::= L_ENTERO:l_E {: RESULT = l_E; :}
          | L_FLOTANTE:l_F {: RESULT = l_F; :}
          | L_BOOLEANO:l_B {: RESULT = l_B; :}
          | L_CHAR:l_C {: RESULT = l_C; :}
          | STRING_LITERAL:l_S {: RESULT = l_S; :}
;


