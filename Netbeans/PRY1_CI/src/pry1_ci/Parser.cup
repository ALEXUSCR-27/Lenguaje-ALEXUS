package pry1_ci;

import java_cup.runtime.*;

import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

/*
action code {:
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
    String tablaActual;

    public void imprimirTabla() {
        for (String key: listaTablasSimbolos.keySet()) {
            System.out.println("Tabla de simbolo: "+ key);
            System.out.println("Valores: ");
            for (String item : listaTablasSimbolos.get(key)) {
                System.out.println(item);
            }
            System.out.println("");
        }
    }
:}
*/


parser code  {: 
    
    public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder(message + ": ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( info.toString() );
    
    System.out.println(m);



  }
/*public void syntax_error(Symbol s) {
    String lexema = s.value.toString();
    int linea = s.right();
    int columna = s.left();
    
    System.out.println("[ERROR SINTACTICO] = Lexema: "+" Fila: "+linea+" Columna: "+columna);

  }*/  
:};





// init with {: :};
//scan with {: return lexer.next_token(); :};



// Terminales
terminal MAIN, FIN_EXPRESION;
terminal IF, ELSE, ELIF, WHILE, DO, FOR, BREAK, RETURN;
terminal BOOL, CHAR, FLOAT, INT, STRING;

// Comentarios
terminal COMENTARIO;

// Entrada y salida estandar
terminal SYS_PRINT, SYS_READ;

// Operadores
terminal EQEQ, PLUS, EQ, TIMES, MINUS, DIVI, NOT_EQ, POWER, MODULO;
terminal NEGACION, CONJUNCION, DISYUNCION, MINUSMINUS, PLUSPLUS, GREATER_THAN, LESS_THAN;
terminal GREATER_THAN_OR_EQ, LESS_THAN_OR_EQ;

// Parentesis
terminal PARENTESISABRE, PARENTESISCIERRA, LLAVESCORCHETEABRE, LLAVESCORCHETECIERRA, COMA;
terminal LLAVESCUADABRE, LLAVESCUADCIERRA, SEMI;

// Literales
terminal java.lang.Number L_ENTERO;
terminal java.lang.Number L_FLOTANTE;
terminal java.lang.Boolean L_BOOLEANO;
terminal java.lang.Character L_CHAR;
terminal java.lang.String STRING_LITERAL;

// Identificador
terminal java.lang.String Identificador;

// No terminales

// Estructura del programa
non terminal inicio, programa, bloqueCod, return, bloqueControl;

// Funciones
non terminal crearFuncion, funcion, parametro, crearParametro;

// Sentencias
non terminal sentencia, crearVariable, crearAsignarVariable, asignarVariable;
//, obtenerDatoString, asignarElementoString;
non terminal entradaEst, salidaEst;

// Estructuras de control
non terminal estructControl, if, elif, else, while, do, for, condicion, break;

// Expresiones
non terminal expresion, operando;
non terminal expresionBinaria, expresionUnaria, expresionRelacion, expresionNegacion, expresionConjuntiva;
non terminal operadorNegacion, operadorBinario, operadorRelacional, operadorUnario, operadorComparacion, operadorConjuntiva;

// Tipos
non terminal literal;
non terminal arreglo, tipoArreglo, elementoArreglo, asignarElementoArreglo, obtenerDatoArreglo;
non terminal tipoVariable, tipoFuncion;



/* Precedencia */
precedence left PLUS, MINUS;
precedence left EQEQ, NOT_EQ;
precedence left GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQ, LESS_THAN_OR_EQ;
precedence left TIMES, DIVI, MODULO;
precedence left POWER;
precedence left CONJUNCION;
precedence left DISYUNCION;
precedence left IF, ELIF, ELSE;
precedence left LLAVESCORCHETEABRE, LLAVESCORCHETECIERRA, PARENTESISABRE, PARENTESISCIERRA; 

start with inicio;

/*Programa Principal*/
inicio ::= programa;
programa ::= INT MAIN PARENTESISABRE PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA {:System.out.println("Main");:}
           | crearFuncion programa
;

// Produccion de bloque de codigo
bloqueCod ::= sentencia 
            | estructControl 
            | return 
            | sentencia bloqueCod
            | estructControl bloqueCod
            | COMENTARIO
;

// Produccion de sentencias
sentencia ::= crearVariable FIN_EXPRESION 
            | crearAsignarVariable FIN_EXPRESION
            | asignarVariable FIN_EXPRESION
            | asignarElementoArreglo FIN_EXPRESION
            | obtenerDatoArreglo FIN_EXPRESION
            | expresion FIN_EXPRESION
            | funcion FIN_EXPRESION
            | entradaEst FIN_EXPRESION
            | salidaEst FIN_EXPRESION
;

// Produccion de creacion y asignacion de variables
crearVariable ::= tipoVariable:tVar Identificador {:System.out.println("Tipo variable: "+tVar);:};

crearAsignarVariable ::= crearVariable EQ literal 
                       | crearVariable EQ expresion 
                       | crearVariable EQ Identificador 
                       | crearVariable EQ funcion
;
asignarVariable	::= Identificador EQ literal 
                  | Identificador EQ expresion 
                  | Identificador EQ Identificador 
                  | Identificador EQ funcion 
;

// Produccion de arreglos  **crear Arreglo?
arreglo ::= tipoArreglo LLAVESCUADABRE LLAVESCUADCIERRA;

asignarElementoArreglo	::= elementoArreglo  EQ L_ENTERO 
                          | elementoArreglo  EQ  L_CHAR
;
// preguntar
elementoArreglo	::= Identificador LLAVESCUADABRE L_ENTERO LLAVESCUADCIERRA
                  | Identificador LLAVESCUADABRE Identificador LLAVESCUADCIERRA
;
obtenerDatoArreglo ::= Identificador LLAVESCUADABRE L_ENTERO LLAVESCUADCIERRA
                     | Identificador LLAVESCUADABRE Identificador LLAVESCUADCIERRA
;

// Produccion de expresiones
expresion ::= expresionBinaria 
            | expresionUnaria 
            | expresionRelacion 
            | expresionNegacion 
            | expresionConjuntiva
;

// Produccion de creacion de funciones
funcion	::= Identificador PARENTESISABRE PARENTESISCIERRA 
          | Identificador PARENTESISABRE parametro PARENTESISCIERRA 
;

crearFuncion ::= tipoFuncion Identificador PARENTESISABRE PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA
                | tipoFuncion Identificador PARENTESISABRE Identificador PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA
                | tipoFuncion Identificador PARENTESISABRE literal  PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA
                | tipoFuncion Identificador PARENTESISABRE crearParametro  PARENTESISCIERRA LLAVESCORCHETEABRE bloqueCod LLAVESCORCHETECIERRA
; 

// Produccion de creacion de parametros
parametro ::= Identificador
            | literal
            | funcion
            | Identificador COMA parametro
;

crearParametro ::= tipoVariable Identificador
                 | tipoVariable Identificador COMA crearParametro
;

// Produccion de funcion de entrada estandar
entradaEst ::= SYS_READ PARENTESISABRE L_ENTERO PARENTESISCIERRA
             | SYS_READ PARENTESISABRE L_FLOTANTE PARENTESISCIERRA
;

// Produccion de funcion de salida estandar
salidaEst ::= SYS_PRINT PARENTESISABRE Identificador PARENTESISCIERRA
            | SYS_PRINT PARENTESISABRE literal PARENTESISCIERRA
;

// Produccion de estructuras de control
estructControl ::= if 
                | elif 
                | else 
                | while
                | do
                | for
;

// Produccion de IF
if	::= IF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
      | IF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA elif
      | IF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA else
;

// Produccion de ELIF
elif ::= if ELIF PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA;

// Produccion de ELSE
else ::= if ELSE LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA;

// Produccion de WHILE
while ::= WHILE PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA;

// Produccion de DO
do ::= DO LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA WHILE PARENTESISABRE condicion PARENTESISCIERRA;

// Produccion de bloque de control
bloqueControl ::= bloqueCod 
                | break
;

for ::= FOR PARENTESISABRE condicion PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
      | FOR PARENTESISABRE L_BOOLEANO PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
      | FOR PARENTESISABRE expresionConjuntiva PARENTESISCIERRA LLAVESCORCHETEABRE bloqueControl LLAVESCORCHETECIERRA
;

// Produccion de BREAK
break ::= BREAK FIN_EXPRESION;

// Produccion de RETURN
return ::= RETURN literal:iDL FIN_EXPRESION {:System.out.println(iDL);:}
         | RETURN expresion:e FIN_EXPRESION {:System.out.println(e);:}
         | RETURN Identificador FIN_EXPRESION
         | RETURN funcion FIN_EXPRESION
;

// Produccion de condicion
condicion ::= L_BOOLEANO 
            | expresionRelacion 
            | expresionNegacion
;

// Produccion de expresiones relaciones
expresionRelacion ::= operando operadorRelacional operando
                    | operando operadorComparacion operando
;
operadorRelacional ::= GREATER_THAN
                     | LESS_THAN
                     | GREATER_THAN_OR_EQ
                     | LESS_THAN_OR_EQ
;
operadorComparacion	::= EQEQ
                      | NOT_EQ
;

// Produccion de expresiones de negacion
expresionNegacion ::= operadorNegacion operando;

operadorNegacion ::= NEGACION;

// Produccion de expresiones unarias
expresionUnaria	::= operando operadorUnario
                  | MINUS operando
;

operadorUnario	::= MINUSMINUS
                  | PLUSPLUS
;

// Produccion de expresiones Binarias
expresionBinaria ::= operando operadorBinario operando;
operadorBinario ::= PLUS
                  | MINUS
                  | DIVI
                  | TIMES
                  | POWER
                  | MODULO
;

// Produccion de expresiones Conjuntivas
expresionConjuntiva	::= operando operadorConjuntiva operando;
operadorConjuntiva	::= CONJUNCION
                      | DISYUNCION
;
operando ::= literal 
           | Identificador 
           | funcion
;

// Produccion de los tipos de funcion
tipoFuncion ::=  INT 
               | BOOL 
               | FLOAT 
;

// Produccion de los tipos de variables
tipoVariable ::= INT 
               | BOOL 
               | FLOAT
               | CHAR 
               | STRING 
               | arreglo
;

// Produccion de los tipos de arreglo
tipoArreglo ::= INT
              | CHAR
;

// Produccion de los literales
literal ::= L_ENTERO
          | L_FLOTANTE
          | L_BOOLEANO
          | L_CHAR
          | STRING_LITERAL
;


